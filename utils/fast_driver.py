#!/usr/bin/env python3
#
# Copyright 2018 Brian T. Park
#
# MIT License
"""
Generate an implementation of ace_segment::Driver which uses the
digitalWriteFast() methods of https://github.com/NicksonYap/digitalWriteFast.
The resulting class can be used where a 'Driver' object created by
'DriverBuilder' would normally be used.

Usage: fast_driver.py [-h] [flags ...]

  --class_name name of class
  --segment_pins space-separated list of segment pins
  --digit_pins space-separate list of digit pins
  --common_cathode
  --common_anode
  --output_header print {class_name}.h file on stdout
  --output_source print {class_name}.cpp file on stdout
  --output_files generate the {class_name}.h and {class_name}.cpp files
  --[no]digital_write_fast

Example:
  $ ./fast_driver.py --digit_pins 10 12 13 --segment_pins 4 5 6 \
      --class_name FastDriver --output_files

Benchmarks for AceSegmentDemo
(frame rate: 60Hz, 4 fields/frame, 16 subfields/field):
  --digital_write_fast
      min: 8us; avg: 13us; max: 84us
      flash/static: 8544/490
  --nodigital_write_fast
      min: 8us; avg: 15us; max: 120us
      flash/static: 8640/490
  LedMatrixDirect
      min: 8us; avg: 16us; max: 140us
      flash/static: 9252/506
"""

import argparse
import logging
import sys


class DriverGenerator:
    HEADER_FILE = """\
// This file was generated by the following script:
//   {0}
//
// DO NOT EDIT

#include <stdint.h>
#include <digitalWriteFast.h>
#include <ace_segment/ModulatingDigitDriver.h>
#include <ace_segment/Util.h>

#ifndef ACE_SEGMENT_{1}_H
#define ACE_SEGMENT_{1}_H

class {1}: public ace_segment::ModulatingDigitDriver {{
  public:
    // Constructor
    {1}(ace_segment::DimmingDigit* dimmingDigits,
            uint8_t numDigits, uint8_t numSubFields):
        ace_segment::ModulatingDigitDriver(
            nullptr /* ledMatrix */, dimmingDigits, numDigits, numSubFields)
    {{}}

    // Destructor
    virtual ~{1}() override {{}}

    virtual void configure() override;
    virtual void displayCurrentField() override;

  private:
    typedef void (*DigitalWriter)(void);

    static const uint8_t kNumSegments = {2};

    // define pin values depending on common cathode or anode wiring
    {3}

    static const uint8_t kSegmentPins[];
    static const uint8_t kDigitPins[];
    static const DigitalWriter kSegmentWriters[];
    static const DigitalWriter kDigitWriters[];

    static void disableDigit(uint8_t digit) {{
      uint8_t index = digit * 2 + kDigitOff;
      DigitalWriter writer = kDigitWriters[index];
      writer();
    }}

    static void enableDigit(uint8_t digit) {{
      uint8_t index = digit * 2 + kDigitOn;
      DigitalWriter writer = kDigitWriters[index];
      writer();
    }}

    static void writeSegment(uint8_t segment, uint8_t value) {{
      uint8_t index = segment * 2 + value;
      DigitalWriter writer = kSegmentWriters[index];
      writer();
    }}

    static void drawSegments(uint8_t pattern) {{
      uint8_t elementMask = 0x1;
      for (uint8_t segment = 0; segment < kNumSegments; segment++) {{
        uint8_t output = (pattern & elementMask) ? kSegmentOn : kSegmentOff;
        writeSegment(segment, output);
        elementMask <<= 1;
      }}
    }}

    // DigitalWriter functions for writing segment pins.
    {4}

    // DigitalWriter functions for writing digit pins.
    {5}
}};

#endif
"""

    SOURCE_FILE = """\
// This file was generated by the following script:
//   {0}
//
// DO NOT EDIT

#include <stdint.h>
#include <Arduino.h>
#include <digitalWriteFast.h>
#include "{1}.h"

const uint8_t {1}::kSegmentPins[] = {{
  {2}
}};

const uint8_t {1}::kDigitPins[] = {{
  {3}
}};

const {1}::DigitalWriter {1}::kSegmentWriters[] = {{
  {4}
}};

const {1}::DigitalWriter {1}::kDigitWriters[] = {{
  {5}
}};

void {1}::configure() {{
  for (uint8_t digit = 0; digit < mNumDigits; digit++) {{
    uint8_t groupPin = kDigitPins[digit];
    pinMode(groupPin, OUTPUT);
    disableDigit(digit);
  }}

  for (uint8_t segment = 0; segment < kNumSegments; segment++) {{
    uint8_t elementPin = kSegmentPins[segment];
    pinMode(elementPin, OUTPUT);
    writeSegment(segment, kSegmentOff);
  }}

  ace_segment::ModulatingDigitDriver::configure();
}}

void {1}::displayCurrentField() {{
  ace_segment::DimmingDigit& dimmingDigit = mDimmingDigits[mCurrentDigit];
  uint8_t brightness = dimmingDigit.brightness;
  if (mCurrentDigit != mPrevDigit) {{
    disableDigit(mPrevDigit);
    mIsCurrentDigitOn = false;
    mCurrentSubFieldMax = ((uint16_t) mNumSubFields * brightness) / 256;
  }}

  if (brightness < 255 && mCurrentSubField >= mCurrentSubFieldMax) {{
    if (mIsCurrentDigitOn) {{
      disableDigit(mCurrentDigit);
      mIsCurrentDigitOn = false;
    }}
  }} else {{
    if (!mIsCurrentDigitOn) {{
      SegmentPatternType segmentPattern = dimmingDigit.pattern;
      if (segmentPattern != mSegmentPattern) {{
        drawSegments(segmentPattern);
        mSegmentPattern = segmentPattern;
      }}
      enableDigit(mCurrentDigit);
      mIsCurrentDigitOn = true;
    }}
  }}

  mCurrentSubField++;
  mPrevDigit = mCurrentDigit;
  if (mCurrentSubField >= mNumSubFields) {{
    ace_segment::Util::incrementMod(mCurrentDigit, mNumDigits);
    mCurrentSubField = 0;
  }}
}}
"""

    def __init__(self, invocation, class_name, segment_pins, digit_pins,
                 common_cathode, output_header, output_source, output_files,
                 digital_write_fast):
        self.invocation = invocation
        self.class_name = class_name
        self.segment_pins = segment_pins
        self.digit_pins = digit_pins
        self.common_cathode = common_cathode
        self.output_header = output_header
        self.output_source = output_source
        self.output_files = output_files
        self.digital_write_fast = digital_write_fast
        logging.info("invocation: %s", self.invocation)
        logging.info("class_name: %s", self.class_name)
        logging.info("segment_pins: %s", self.segment_pins)
        logging.info("digit_pins: %s", self.digit_pins)
        logging.info("common_cathode: %s", self.common_cathode)
        logging.info("digital_write_fast: %s", self.digital_write_fast)

    def run(self):
        header = self.HEADER_FILE.format(self.invocation, self.class_name,
                                         len(self.segment_pins),
                                         self.get_on_off_constants(),
                                         self.get_element_writers(),
                                         self.get_group_writers())
        if self.output_header:
            print(header)
        if self.output_files:
            header_filename = self.class_name + ".h"
            with open(header_filename, 'w', encoding='utf-8') as header_file:
                print(header, end='', file=header_file)
            logging.info("Created %s", header_filename)

        source = self.SOURCE_FILE.format(self.invocation, self.class_name,
                                         self.get_element_pins_array(),
                                         self.get_group_pins_array(),
                                         self.get_element_writers_array(),
                                         self.get_group_writers_array())
        if self.output_source:
            print(source)
        if self.output_files:
            source_filename = self.class_name + ".cpp"
            with open(source_filename, 'w', encoding='utf-8') as source_file:
                print(source, end='', file=source_file)
            logging.info("Created %s", source_filename)

    def get_element_pins_array(self):
        entries = []
        for pin in self.segment_pins:
            entry = ('%s,' % (pin))
            entries.append(entry)
        return '\n  '.join(entries)

    def get_group_pins_array(self):
        entries = []
        for pin in self.digit_pins:
            entry = ('%s,' % (pin))
            entries.append(entry)
        return '\n  '.join(entries)

    def get_element_writers(self):
        writers = []
        if self.digital_write_fast:
            method = 'digitalWriteFast'
        else:
            method = 'digitalWrite'
        for i in range(len(self.segment_pins)):
            pin = self.segment_pins[i]
            low = ('static void digitalWriteFastSegment%02dLow() ' +
                   '{ %s(%s, LOW); }') % (i, method, pin)
            high = ('static void digitalWriteFastSegment%02dHigh() ' +
                    '{ %s(%s, HIGH); }') % (i, method, pin)
            writers.append(low)
            writers.append(high)
        return '\n    '.join(writers)

    def get_element_writers_array(self):
        entries = []
        for i in range(len(self.segment_pins)):
            low = ('digitalWriteFastSegment%02dLow,' % (i))
            high = ('digitalWriteFastSegment%02dHigh,' % (i))
            entries.append(low)
            entries.append(high)
        return '\n  '.join(entries)

    def get_group_writers(self):
        writers = []
        if self.digital_write_fast:
            method = 'digitalWriteFast'
        else:
            method = 'digitalWrite'
        for i in range(len(self.digit_pins)):
            pin = self.digit_pins[i]
            low = ('static void digitalWriteFastDigit%02dLow() ' +
                   '{ %s(%s, LOW); }') % (i, method, pin)
            high = ('static void digitalWriteFastDigit%02dHigh() ' +
                    '{ %s(%s, HIGH); }') % (i, method, pin)
            writers.append(low)
            writers.append(high)
        return '\n    '.join(writers)

    def get_group_writers_array(self):
        entries = []
        for i in range(len(self.digit_pins)):
            low = ('digitalWriteFastDigit%02dLow,' % (i))
            high = ('digitalWriteFastDigit%02dHigh,' % (i))
            entries.append(low)
            entries.append(high)
        return '\n  '.join(entries)

    def get_on_off_constants(self):
        constants = []
        if self.common_cathode:
            constants.append('static const uint8_t kDigitOn = LOW;')
            constants.append('static const uint8_t kDigitOff = HIGH;')
            constants.append('static const uint8_t kSegmentOn = HIGH;')
            constants.append('static const uint8_t kSegmentOff = LOW;')
        else:
            constants.append('static const uint8_t kDigitOn = HIGH;')
            constants.append('static const uint8_t kDigitOff = LOW;')
            constants.append('static const uint8_t kSegmentOn = LOW;')
            constants.append('static const uint8_t kSegmentOff = HIGH;')
        return '\n    '.join(constants)


def main():
    # Configure command line flags.
    parser = argparse.ArgumentParser(description='Generate Fast Driver.')
    parser.add_argument(
        '--class_name', help='Name of the Driver class', required=True)
    parser.add_argument(
        '--segment_pins',
        help='Space-separated list of segment pins (ordered from 0 to 7)',
        nargs='+',
        type=int,
        required=True)
    parser.add_argument(
        '--digit_pins',
        help='Comma-separated list of digit pins (ordered from 0 to n)',
        nargs='+',
        type=int,
        required=True)
    parser.add_argument(
        '--common_cathode',
        help='LED display uses common cathode on the digit (default: True)',
        dest='common_cathode',
        action="store_true",
        default=True)
    parser.add_argument(
        '--common_anode',
        help='LED display uses common anode on the digit (default: False)',
        dest='common_cathode',
        action="store_false")
    parser.add_argument(
        '--output_header',
        help='Output the *.h header file for debugging (default: False)',
        action="store_true")
    parser.add_argument(
        '--output_source',
        help='Output the *.cpp source file for debugging (default: False)',
        action="store_true")
    parser.add_argument(
        '--output_files',
        help='Create class_name.h and class_name.cpp files (default: False)',
        action="store_true",
        default=False)
    parser.add_argument(
        '--digital_write_fast',
        help='Use digitalWriteFast() instead of digitalWrite() (default: True)',
        dest='digital_write_fast',
        action="store_true",
        default=True)
    parser.add_argument(
        '--nodigital_write_fast',
        help='Use digitalWrite() instead of digitalWriteFast()',
        dest='digital_write_fast',
        action="store_false")
    args = parser.parse_args()

    # Configure logging.
    logging.basicConfig(level=logging.INFO)

    # How the script was invoked
    invocation = " ".join(sys.argv)

    generator = DriverGenerator(invocation, args.class_name, args.segment_pins,
                                args.digit_pins, args.common_cathode,
                                args.output_header, args.output_source,
                                args.output_files, args.digital_write_fast)
    generator.run()


if __name__ == '__main__':
    main()
